Алгоритм Монтгомери Алгоритм Монтгомери — приём, позволяющий ускорить выполнение операций умножения и возведения в квадрат, необходимых при возведении числа в степень по модулю, когда модуль велик (порядка сотен бит). Был предложен в 1985 году Питером Монтгомери. По данным целым числам a, b < n, r, НОД    ( r , n ) = 1   {\displaystyle (r,n)=1}   алгоритм Монтгомери вычисляет     M o n P r o ( a , b ) = a ⋅ b ⋅  r  − 1    mod   n   {\displaystyle MonPro(a,b)=a\cdot b\cdot r^{-1}\mod {n}}    Содержание  1 Умножение Монтгомери 2 Возведение в степень Монтгомери 3 Примечания 4 Литература   Умножение Монтгомери[править | править код] Положим     r =  2  k     {\displaystyle r=2^{k}}  . Определим n-остаток (n-residue) числа     a < n   {\displaystyle a<n}   как        a ¯    = a ⋅ r  mod   n   {\displaystyle {\bar {a}}=a\cdot r\mod {n}}  . Алгоритм Монтгомери использует свойство, что множество     { a ⋅ r  mod   n ∣ 0 ⩽ a ⩽ n − 1 }   {\displaystyle \{a\cdot r\mod {n}\mid 0\leqslant a\leqslant n-1\}}   является полной системой вычетов, то есть содержит все числа от 0 до n-1. MonPro вычисляет        c ¯    =    a ¯    ⋅    b ¯    ⋅  r  − 1    mod   n   {\displaystyle {\bar {c}}={\bar {a}}\cdot {\bar {b}}\cdot r^{-1}\mod {n}}  . Результат является n-остатком от     c = a ⋅ b  mod   n   {\displaystyle c=a\cdot b\mod {n}}  , так как        c ¯    =    a ¯    ⋅    b ¯    ⋅  r  − 1    mod   n = a ⋅ r ⋅ b ⋅ r ⋅  r  − 1    mod   n = c ⋅ r  mod   n   {\displaystyle {\bar {c}}={\bar {a}}\cdot {\bar {b}}\cdot r^{-1}\mod {n}=a\cdot r\cdot b\cdot r\cdot r^{-1}\mod {n}=c\cdot r\mod {n}}   Определим n' так, что     r ⋅  r  − 1   − n ⋅  n ′  = 1   {\displaystyle r\cdot r^{-1}-n\cdot n'=1}  .      r  − 1     {\displaystyle r^{-1}}   и      n ′    {\displaystyle n'}   можно вычислить с помощью расширенного алгоритма Евклида. Функция     M o n P r o (    a ¯    ,    b ¯    )   {\displaystyle MonPro({\bar {a}},{\bar {b}})}    1.                         t         =                                                a               ¯                                          ⋅                                                b               ¯                                                  {\displaystyle t={\bar {a}}\cdot {\bar {b}}}     2.                         u         =         (         t         +         (         t         ⋅                    n           ′                           mod                           r         )         ⋅         n         )                    /                  r                 {\displaystyle u=(t+(t\cdot n'\mod {r})\cdot n)/r}     3. while                         (         u         >=         n         )         u         =         u         −         n                 {\displaystyle (u>=n)u=u-n}     4. return                          u                 {\displaystyle u}      Операции умножения и деления на r выполняются очень быстро, так как при     r =  2  k     {\displaystyle r=2^{k}}   представляют собой просто сдвиги бит, а при     r > n   {\displaystyle r>n}   цикл в строчке 3 выполнится не более одного раза. Таким образом алгоритм Монтгомери быстрее обычного вычисления     a ⋅ b  mod   n   {\displaystyle a\cdot b\mod {n}}  , которое содержит деление на n. Однако вычисление n' и перевод чисел в n-остатки и обратно — трудоёмкие операции, вследствие чего применять алгоритм Монтгомери при однократном вычислении произведения двух чисел представляется неразумным.  Возведение в степень Монтгомери[править | править код] Использование алгоритма Монтгомери оправдывает себя при возведении числа в степень по модулю      a  e    mod   n   {\displaystyle a^{e}\mod {n}}  . Функция     M o d E x p ( a , e , n )   {\displaystyle ModExp(a,e,n)}    1.                                                                a               ¯                                          =         a         ⋅         r                  mod                           n                 {\displaystyle {\bar {a}}=a\cdot r\mod {n}}     2.                                                                x               ¯                                          =         1         ⋅         r                  mod                           n                 {\displaystyle {\bar {x}}=1\cdot r\mod {n}}     3. for i=j-1 downto 0                                                                     x               ¯                                          =         M         o         n         P         r         o         (                                                x               ¯                                          ,                                                x               ¯                                          )                 {\displaystyle {\bar {x}}=MonPro({\bar {x}},{\bar {x}})}          if                                    e                        i                             =         1                 {\displaystyle e_{i}=1}     then                                                                x               ¯                                          =         M         o         n         P         r         o         (                                                x               ¯                                          ,                                                a               ¯                                          )                 {\displaystyle {\bar {x}}=MonPro({\bar {x}},{\bar {a}})}     4. return                         x         =         M         o         n         P         r         o         (                                                x               ¯                                          ,         1         )                 {\displaystyle x=MonPro({\bar {x}},1)}      Возведение числа в степень битовой длины k алгоритмом «возводи в квадрат и перемножай» включает в себя от k до 2k умножений, где k имеет порядок сотен или тысяч бит. При использовании алгоритма возведения в степень Монтгомери объём дополнительных вычислений фиксирован (вычисления      n ′    {\displaystyle n'}  ,        a ¯      {\displaystyle {\bar {a}}}  ,        x ¯      {\displaystyle {\bar {x}}}   в начале и     M o n P r o (    x ¯    , 1 )   {\displaystyle MonPro({\bar {x}},1)}   в конце), а операция MonPro выполняется быстрее обычного умножения по модулю[1], поэтому алгоритм возведения в степень Монтгомери даст выигрыш в производительности по сравнению с алгоритмом «возводи в квадрат и перемножай».  Примечания[править | править код]   ↑ Analyzing and Comparing Montgomery Multiplication Algorithms Архивировано 1 июля 2010 года.   Литература[править | править код] Analyzing and Comparing Montgomery Multiplication Algorithms Menezes A. J., Oorschot P. v., Vanstone S. A. Chapter 14. Efficient Implementation // Handbook of Applied Cryptography — CRC Press, 1996. — 816 p. — (Discrete Mathematics and Its Applications) — ISBN 978-0-8493-8523-0<a href="https://wikidata.org/wiki/Track:Q27123086"></a><a href="https://wikidata.org/wiki/Track:Q4723156"></a><a href="https://wikidata.org/wiki/Track:Q15262410"></a><a href="https://wikidata.org/wiki/Track:Q954828"></a><a href="https://wikidata.org/wiki/Track:Q21725116"></a><a href="https://wikidata.org/wiki/Track:Q7437437"></a>       Это заготовка статьи по математике. Вы можете помочь проекту, дополнив её.     