Метод золотого сечения Метод золотого сечения — метод поиска экстремума действительной функции одной переменной на заданном отрезке. В основе метода лежит принцип деления отрезка в пропорциях золотого сечения. Является одним из простейших вычислительных методов решения задач оптимизации. Впервые представлен Джеком Кифером в 1953 году.  Содержание  1 Описание метода  1.1 Алгоритм 1.2 Формализация   2 Метод чисел Фибоначчи  2.1 Алгоритм   3 Литература 4 См. также   Описание метода[править | править код] Пусть задана функция     f ( x ) :  [ a ,  b ] →  R  ,  f ( x ) ∈  C  ( [ a ,  b ] )   {\displaystyle f(x):\;[a,\;b]\to \mathbb {R} ,\;f(x)\in \mathrm {C} ([a,\;b])}  . Тогда для того, чтобы найти неопределённое значение этой функции на заданном отрезке, отвечающее критерию поиска (пусть это будет минимум), рассматриваемый отрезок делится в пропорции золотого сечения в обоих направлениях, то есть выбираются две точки      x  1     {\displaystyle x_{1}}   и      x  2     {\displaystyle x_{2}}   такие, что:    Иллюстрация выбора промежуточных точек метода золотого сечения.        b − a   b −  x  1      =    b − a    x  2   − a    = Φ =    1 +   5    2   = 1.618 …   {\displaystyle {\frac {b-a}{b-x_{1}}}={\frac {b-a}{x_{2}-a}}=\Phi ={\frac {1+{\sqrt {5}}}{2}}=1.618\ldots }  , где     Φ   {\displaystyle \Phi }   — пропорция золотого сечения.  Таким образом:            x  1     =   b −    ( b − a )  Φ        x  2     =   a +    ( b − a )  Φ         {\displaystyle {\begin{array}{ccc}x_{1}&=&b-{\frac {(b-a)}{\Phi }}\\x_{2}&=&a+{\frac {(b-a)}{\Phi }}\end{array}}}   То есть точка      x  1     {\displaystyle x_{1}}   делит отрезок     [ a ,   x  2   ]   {\displaystyle [a,\;x_{2}]}   в отношении золотого сечения. Аналогично      x  2     {\displaystyle x_{2}}   делит отрезок     [  x  1   ,  b ]   {\displaystyle [x_{1},\;b]}   в той же пропорции. Это свойство и используется для построения итеративного процесса.  Алгоритм[править | править код] На первой итерации заданный отрезок делится двумя симметричными относительно его центра точками и рассчитываются значения в этих точках. После чего тот из концов отрезка, к которому среди двух вновь поставленных точек ближе оказалась та, значение в которой максимально (для случая поиска минимума), отбрасывают. На следующей итерации в силу показанного выше свойства золотого сечения уже надо искать всего одну новую точку. Процедура продолжается до тех пор, пока не будет достигнута заданная точность. Формализация[править | править код] Шаг 1. Задаются начальные границы отрезка     a ,  b   {\displaystyle a,\;b}   и точность     ε   {\displaystyle \varepsilon }  . Шаг 2. Рассчитывают начальные точки деления:      x  1   = b −    ( b − a )  Φ   ,   x  2   = a +    ( b − a )  Φ     {\displaystyle x_{1}=b-{\frac {(b-a)}{\Phi }},\quad x_{2}=a+{\frac {(b-a)}{\Phi }}}   и значения в них целевой функции:      y  1   = f (  x  1   ) ,   y  2   = f (  x  2   )   {\displaystyle y_{1}=f(x_{1}),\;y_{2}=f(x_{2})}  . Если      y  1   ≥  y  2     {\displaystyle y_{1}\geq y_{2}}   (для поиска max изменить неравенство на      y  1   ≤  y  2     {\displaystyle y_{1}\leq y_{2}}  ), то     a =  x  1     {\displaystyle a=x_{1}}   Иначе     b =  x  2     {\displaystyle b=x_{2}}  . Шаг 3. Если      |  b − a  |  < ε   {\displaystyle |b-a|<\varepsilon }  , то     x =    a + b  2     {\displaystyle x={\frac {a+b}{2}}}   и останов. Иначе возврат к шагу 2. Алгоритм взят из источника: Джон Г.Мэтьюз, Куртис Д.Финк. "Численные методы. Использование MATLAB". — М, СПб: "Вильямс", 2001. — 716 с.  Простейшая реализация данного алгоритма на языке F# (содержит лишние вычисления минимизируемой функции):let phi = 0.5 * (1.0 + sqrt 5.0) let rec minimize f eps a b =      if abs(b - a) < eps then          0.5 * (a + b)     else          let t = (b - a) / phi         let x1, x2 = b - t, a + t         if f x1 >= f x2 then             minimize f eps x1 b         else             minimize f eps a x2 // Примеры вызова: minimize cos 1e-6 0.0 6.28 // = 3.141592794; число итераций: 33; функция f вызвана 64 раза. minimize (fun x -> (x - 1.0)**2.0) 1e-6 0.0 10.0  // = 1.000000145; число итераций: 35; функция f вызвана 68 раз.  Метод чисел Фибоначчи[править | править код] В силу того, что в асимптотике     Φ =  lim  n → ∞      F  n + 1    F  n       {\displaystyle \Phi =\lim _{n\to \infty }{\frac {F_{n+1}}{F_{n}}}}  , метод золотого сечения может быть трансформирован в так называемый метод чисел Фибоначчи. Однако при этом в силу свойств чисел Фибоначчи количество итераций строго ограничено. Это удобно, если сразу задано количество возможных обращений к функции.  Алгоритм[править | править код] Шаг 1. Задаются начальные границы отрезка     a ,  b   {\displaystyle a,\;b}   и число итераций     n   {\displaystyle n}  , рассчитывают начальные точки деления:      x  1   = a + ( b − a )    F  n − 2    F  n     ,   x  2   = a + ( b − a )    F  n − 1    F  n       {\displaystyle x_{1}=a+(b-a){\frac {F_{n-2}}{F_{n}}},\quad x_{2}=a+(b-a){\frac {F_{n-1}}{F_{n}}}}   и значения в них целевой функции:      y  1   = f (  x  1   ) ,   y  2   = f (  x  2   )   {\displaystyle y_{1}=f(x_{1}),\;y_{2}=f(x_{2})}  . Шаг 2.     n = n − 1   {\displaystyle n=n-1}  . Если      y  1   >  y  2     {\displaystyle y_{1}>y_{2}}  , то     a =  x  1   ,   x  1   =  x  2   ,   x  2   = b − (  x  1   − a ) ,   y  1   =  y  2   ,   y  2   = f (  x  2   )   {\displaystyle a=x_{1},\;x_{1}=x_{2},\;x_{2}=b-(x_{1}-a),\;y_{1}=y_{2},\;y_{2}=f(x_{2})}  . Иначе     b =  x  2   ,   x  2   =  x  1   ,   x  1   = a + ( b −  x  2   ) ,   y  2   =  y  1   ,   y  1   = f (  x  1   )   {\displaystyle b=x_{2},\;x_{2}=x_{1},\;x_{1}=a+(b-x_{2}),\;y_{2}=y_{1},\;y_{1}=f(x_{1})}  . Шаг 3. Если     n = 1   {\displaystyle n=1}  , то     x =     x  1   +  x  2    2     {\displaystyle x={\frac {x_{1}+x_{2}}{2}}}   и остановка. Иначе возврат к шагу 2. Литература[править | править код] Акулич И. Л. Математическое программирование в примерах и задачах: Учеб. пособие для студентов эконом. спец. вузов. — М.: Высш. шк., 1986. Гилл Ф., Мюррей У., Райт М. Практическая оптимизация. Пер. с англ. — М.: Мир, 1985. Коршунов Ю. М. Математические основы кибернетики. — М.: Энергоатомиздат, 1972. Максимов Ю. А., Филлиповская Е. А. Алгоритмы решения задач нелинейного программирования. — М.: МИФИ, 1982. Максимов Ю. А. Алгоритмы линейного и дискретного программирования. — М.: МИФИ, 1980. Корн Г., Корн Т. Справочник по математике для научных работников и инженеров. — М.: Наука, 1970. — С. 575—576. Корн Г., Корн Т. Справочник по математике для научных работников и инженеров. — М.: Наука, 1973. — С. 832 с илл.. Джон Г. Мэтьюз, Куртис Д. Финк. Численные методы. Использование MATLAB. — 3-е издание. — М., СПб.: Вильямс, 2001. — С. 716. См. также[править | править код] Золотое сечение Числа Фибоначчи Методы оптимизацииОдномерные Метод золотого сечения Дихотомия Метод парабол Перебор по сетке Метод равномерного блочного поиска Метод Фибоначчи Троичный поиск Метод Пиявского Метод Стронгина Прямые методы Метод Гаусса Метод Нелдера — Мида  Метод Хука — Дживса Метод конфигураций Метод Розенброка Первого порядка Градиентный спуск Метод Зойтендейка Покоординатный спуск Метод сопряжённых градиентов Квазиньютоновские методы Алгоритм Левенберга — Марквардта Второго порядка Метод Ньютона Метод Ньютона — Рафсона Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS) Стохастические Метод Монте-Карло Имитация отжига Эволюционные алгоритмы Дифференциальная эволюция Муравьиный алгоритм Метод роя частиц Алгоритм пчелиной колонии Метод случайных блужданий Методы линейногопрограммирования Симплекс-метод Алгоритм Гомори Метод эллипсоидов Метод потенциалов Методы нелинейногопрограммирования Последовательное квадратичное программирование Золотое сечение«Золотые» фигуры Золотой прямоугольник Золотой треугольник Золотой ромб Золотой эллипс Треугольник Кеплера Золотой угол Золотая спираль Золотой гномон Другие сечения Сверхзолотое сечение Серебряное сечение Бронзовое сечение Прочее Числа Фибоначчи Правило третей Метод золотого сечения Золотое сечение в пентаграмме     